package sqlc

// ===================================================================================================================== //
//                                             SQLC Usage Instructions                                                   //
// ===================================================================================================================== //

// MIGRATE

// Using [golang-migrate](https://github.com/golang-migrate/migrate)

// To run migrate commands (from backend folder):
// migrate -path db/migrations -database "<connection_string>" -verbose <command_to_be_executed>

// To create a new migration (from backend folder):
// migrate create -ext sql -dir db/migrations -seq <name_of_migration>

//

// SQLC

// sqlc generate
// after having modified the query and schema files

//

// VALIDATOR

// Using [golang validator](https://pkg.go.dev/github.com/go-playground/validator/v10#section-readme)

// Allows for input validation on struct- or field-levels.

//

// BLUEMONDAY

// Using [bluemonday](https://pkg.go.dev/github.com/microcosm-cc/bluemonday@v1.0.26)

// Allows for HTML sanitization of user input, preventing XSS attacks.

//

// ===================================================================================================================== //
//                                                 Real Code Below                                                       //
// ===================================================================================================================== //

import (
	"errors"
	"time"

	"github.com/go-playground/validator/v10"
	"github.com/google/uuid"
	_ "github.com/lib/pq"
	"github.com/microcosm-cc/bluemonday"
)

func (postCommentParams PostCommentParams) Sanitize(sanitizationPolicy bluemonday.Policy) PostCommentParams {
	// Fields to Sanitize:
	//
	// CommentID   pgtype.UUID
	// ListingID   string
	// UserIp      string
	// UserID      string
	// Username    string
	// CommentText string

	sanitizedCommentParams := postCommentParams

	// CommentID is a pgtype.UUID (binary), and validated to ensure it is typed correctly, so no sanitization needed
	sanitizedCommentParams.ListingID = sanitizationPolicy.Sanitize(sanitizedCommentParams.ListingID)
	sanitizedCommentParams.UserIp = sanitizationPolicy.Sanitize(sanitizedCommentParams.UserIp)
	sanitizedCommentParams.UserID = sanitizationPolicy.Sanitize(sanitizedCommentParams.UserID)
	sanitizedCommentParams.Username = sanitizationPolicy.Sanitize(sanitizedCommentParams.Username)
	sanitizedCommentParams.CommentText = sanitizationPolicy.Sanitize(sanitizedCommentParams.CommentText)

	return sanitizedCommentParams
}

// PostCommentParamsValidation is the function registered with the API's Validator singleton
// in order to validate the PostCommentParams struct. Tags are not added to the struct directly
// because its code is auto-generated by SQLC and cannot be edited.
//
// Input:
//   - sl: a validator object that allows this function to be registed as a custom struct validator.
func PostCommentParamsValidation(sl validator.StructLevel) {
	// Fields to validate:
	//
	// CommentID   pgtype.UUID
	// ListingID   string
	// UserIp      string
	// UserID      string
	// Username    string
	// CommentText string

	postCommentParams := sl.Current().Interface().(PostCommentParams)

	// COMMENT ID

	// Convert the comment ID from pgtype.UUID to uuid.UUID.
	commentUUID, err := uuid.FromBytes(postCommentParams.CommentID.Bytes[:])
	if err != nil {
		// If the conversion fails, return an error indicating the format is invalid.
		sl.ReportError(postCommentParams.CommentID, "CommentID", "CommentID", "uuid", "")
	}

	//log.Println("Validating CommentID:", commentUUID.String())

	// TODO: check that this test ensures UUID is not empty and not invalid
	// Example uuid : f81d4fae-7dec-11d0-a765-00a0c91e6bf6
	commentIdValidation := "required,uuid"
	err = sl.Validator().Var(commentUUID, commentIdValidation)
	if err != nil || uuid.Validate(commentUUID.String()) != nil || customUUIDValidator(commentUUID) != nil {
		sl.ReportError(postCommentParams.CommentID, "CommentID", "CommentID", commentIdValidation, "")
	}

	// LISTING ID

	listingIdValidation := "required,number,excludes=.,min=1,max=20"
	err = sl.Validator().Var(postCommentParams.ListingID, listingIdValidation)
	if err != nil {
		sl.ReportError(postCommentParams, "ListingID", "ListingID", listingIdValidation, "")
	}

	// USER IP

	userIpValidation := "required,ip"
	err = sl.Validator().Var(postCommentParams.UserIp, userIpValidation)
	if err != nil {
		sl.ReportError(postCommentParams, "UserIp", "UserIp", userIpValidation, "")
	}

	// USER ID

	userIdValidation := "required,uuid"
	userUUID, err := uuid.Parse(postCommentParams.UserID)
	if err != nil {
		// If the conversion fails, return an error indicating the format is invalid.
		sl.ReportError(postCommentParams.UserID, "UserID", "UserID", "uuid", "")
	}
	err = sl.Validator().Var(postCommentParams.UserID, userIdValidation)
	if err != nil || uuid.Validate(postCommentParams.UserID) != nil || customUUIDValidator(userUUID) != nil {
		sl.ReportError(postCommentParams.UserID, "UserID", "UserID", userIdValidation, "")
	}

	// USERNAME

	usernameValidation := "required,alphanum,min=3,max=25"
	err = sl.Validator().Var(postCommentParams.Username, usernameValidation)
	if err != nil {
		sl.ReportError(postCommentParams.Username, "Username", "Username", usernameValidation, "")
	}

	// COMMENT TEXT

	commentTextValidation := "required,printascii,min=1,max=300"
	err = sl.Validator().Var(postCommentParams.CommentText, commentTextValidation)
	if err != nil {
		sl.ReportError(postCommentParams.CommentText, "CommentText", "CommentText", commentTextValidation, "")
	}
}

// customUUIDValidator runs extra checks to ensure that a V7 UUID is valid.
// It primarily checks to ensure that the time component of the UUID is logical,
// and that the version is correct.
//
// Input:
//   - uuid: the UUID to validate.
//
// Output:
//   - error: returns nil if the UUID is valid, or an error if it is not.
func customUUIDValidator(uuid uuid.UUID) error {
	// VALIDATE TIMESTAMP

	uuidTimestamp := getUUIDTimestamp(uuid)

	// Define the past and future reference times for validation.

	// (Tue May 27 2025 23:53:20 GMT+0000)
	pastReferenceTime := time.Unix(1748390000, 0)

	// 10 hours in the future
	futureReferenceTime := time.Now().Add(10 * time.Hour)

	// Check uuid's timestamp against reference timestamps
	if uuidTimestamp.Before(pastReferenceTime) || uuidTimestamp.After(futureReferenceTime) {
		return errors.New("UUID time component is not within the valid range")
	}

	// VERSION CHECK

	if uuid.Version() != 7 {
		return errors.New("UUID version is not 7")
	}

	return nil
}

func getUUIDTimestamp(uuid uuid.UUID) time.Time {
	// Check the time component of the UUID.
	uuidByteTimeComponent := uuid[0:6]

	// Convert 6 bytes to uint64 by shifting
	var intTimestamp uint64
	for i := 0; i < 6; i++ {
		intTimestamp = (intTimestamp << 8) | uint64(uuidByteTimeComponent[i])
	}

	convertedTimestamp := time.UnixMilli(int64(intTimestamp))

	return convertedTimestamp
}

// EXAMPLE VALIDATOR USAGE

/* // User contains user information
type User struct {
	FirstName      string     `validate:"required"`
	LastName       string     `validate:"required"`
	Age            uint8      `validate:"gte=0,lte=130"`
	Email          string     `validate:"required,email"`
	Gender         string     `validate:"oneof=male female prefer_not_to"`
	FavouriteColor string     `validate:"iscolor"`                // alias for 'hexcolor|rgb|rgba|hsl|hsla'
	Addresses      []*Address `validate:"required,dive,required"` // a person can have a home and cottage...
}

// Address houses a users address information
type Address struct {
	Street string `validate:"required"`
	City   string `validate:"required"`
	Planet string `validate:"required"`
	Phone  string `validate:"required"`
} */

// ================================================================================================================== //
//                                                Old Code Below                                                      //
// ================================================================================================================== //

/* // returns a queries struct that can be used to execute queries and a
// function to close the connection linked to it
func GetConnection() (*pgx.Conn, error) {
	godotenv.Load()
	connStr := os.Getenv("CONNECTION_STRING")
	conn, err := pgx.Connect(context.Background(), connStr)
	if err != nil {
		return nil, err
	}
	return conn, nil
} */

// use tx.Commit() if there are no errors at the end of the transaction
// if error call tx.Rollback()
// tx.Rollback() can be defered since if Commit is called first then rollback has no effect

// queries := New(conn)

// tx, err := conn.Begin(ctx)
