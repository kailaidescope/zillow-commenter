package sqlc

// ===================================================================================================================== //
//                                             SQLC Usage Instructions                                                   //
// ===================================================================================================================== //

//// Using [golang-migrate](https://github.com/golang-migrate/migrate)

// To run migrate commands (from backend folder):
// migrate -path db/migrations -database "<connection_string>" -verbose <command_to_be_executed>

// To create a new migration (from backend folder):
// migrate create -ext sql -dir db/migrations -seq <name_of_migration>

//sqlc generate
//after having modified the query and schema files

// ===================================================================================================================== //
//                                                 Real Code Below                                                       //
// ===================================================================================================================== //

import (
	"errors"
	"fmt"

	"github.com/go-playground/validator/v10"
	"github.com/google/uuid"
	_ "github.com/lib/pq"
)

/* // User contains user information
type User struct {
	FirstName      string     `validate:"required"`
	LastName       string     `validate:"required"`
	Age            uint8      `validate:"gte=0,lte=130"`
	Email          string     `validate:"required,email"`
	Gender         string     `validate:"oneof=male female prefer_not_to"`
	FavouriteColor string     `validate:"iscolor"`                // alias for 'hexcolor|rgb|rgba|hsl|hsla'
	Addresses      []*Address `validate:"required,dive,required"` // a person can have a home and cottage...
}

// Address houses a users address information
type Address struct {
	Street string `validate:"required"`
	City   string `validate:"required"`
	Planet string `validate:"required"`
	Phone  string `validate:"required"`
} */

// PostCommentParamsValidation is the function registered with the API's Validator singleton
// in order to validate the PostCommentParams struct. Tags are not added to the struct directly
// because its code is auto-generated by SQLC and cannot be edited.
//
// Input:
//   - sl: a validator object that allows this function to be registed as a custom struct validator.
func PostCommentParamsValidation(sl validator.StructLevel) error {
	// Fields to validate:
	//
	// CommentID   pgtype.UUID
	// ListingID   string
	// UserIp      string
	// UserID      string
	// Username    string
	// CommentText string

	postCommentParams := sl.Current().Interface().(PostCommentParams)

	// Convert the comment ID from pgtype.UUID to uuid.UUID.
	commentUUID, err := uuid.FromBytes(postCommentParams.CommentID.Bytes[:])
	if err != nil {
		// If the conversion fails, return an error indicating the format is invalid.
		sl.ReportError(postCommentParams.CommentID, "CommentID", "CommentID", "uuid", "")
	}

	// TODO: check that this test ensures UUID is not empty and not invalid
	// Example uuid : f81d4fae-7dec-11d0-a765-00a0c91e6bf6
	if uuid.Validate(commentUUID.String()) != nil {
		sl.ReportError(postCommentParams.CommentID, "CommentID", "CommentID", "required,uuid", "")
	}

	listingIdValidation := "required,numeric"
	err = sl.Validator().Var(postCommentParams.ListingID, listingIdValidation)
	if err != nil {
		sl.ReportError(postCommentParams, "ListingID", "ListingID", listingIdValidation, "")
	}

	errs := sl.Validator().Var(postCommentParams.CommentID, "required,email")

	if errs != nil {
		fmt.Println(errs) // output: Key: "" Error:Field validation for "" failed on the "email" tag
		return
	}

	// email ok, move on
	return errors.New("function not yet implmented")
}

// ================================================================================================================== //
//                                                Old Code Below                                                      //
// ================================================================================================================== //

/* // returns a queries struct that can be used to execute queries and a
// function to close the connection linked to it
func GetConnection() (*pgx.Conn, error) {
	godotenv.Load()
	connStr := os.Getenv("CONNECTION_STRING")
	conn, err := pgx.Connect(context.Background(), connStr)
	if err != nil {
		return nil, err
	}
	return conn, nil
} */

// use tx.Commit() if there are no errors at the end of the transaction
// if error call tx.Rollback()
// tx.Rollback() can be defered since if Commit is called first then rollback has no effect

// queries := New(conn)

// tx, err := conn.Begin(ctx)
